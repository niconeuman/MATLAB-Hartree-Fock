function gabcd = shellOS(basis_a,basis_b,basis_c,basis_d,L1,L2,L3,L4,Boys_Table)

if ( L1 == 1 && L2 == 0 && L3 == 1 && L4 == 1) 

    gpspp_swap = shellOS(basis_c,basis_d,basis_a,basis_b,L3,L4,L1,L2,Boys_Table);
    gabcd = permute(gpspp_swap,[3 4 1 2]);

elseif( L1 == 1 && L2 == 1 && L3 == 0 && L4 == 0)

gppss = zeros(3,3,1,1);

    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gppss_temp = zeros(3,3,1,1);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;
                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gppss_temp2 = zeros(3,3,1,1);
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gppss_temp3 = zeros(3,3,1,1);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
                        
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                       
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                                     
                            gppss_temp4 = OSppss(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gppss_temp3 = gppss_temp3 + gppss_temp4*c4*N4;
                            
                        end
                        gppss_temp2 = gppss_temp2 + gppss_temp3*c3*N3;
                    end
                    gppss_temp = gppss_temp + gppss_temp2*c2*N2;
            end
            gppss = gppss + gppss_temp*c1*N1;   
    end    
gabcd = gppss;

elseif( L1 == 0 && L2 == 0 && L3 == 1 && L4 == 1)

gsspp = zeros(1,1,3,3);

    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gsspp_temp = zeros(1,1,3,3);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;
                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gsspp_temp2 = zeros(1,1,3,3);
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gsspp_temp3 = zeros(1,1,3,3);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
                        
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                       
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                                     
                            gsspp_temp4 = OSsspp(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gsspp_temp3 = gsspp_temp3 + gsspp_temp4*c4*N4;
                            
                        end
                        gsspp_temp2 = gsspp_temp2 + gsspp_temp3*c3*N3;
                    end
                    gsspp_temp = gsspp_temp + gsspp_temp2*c2*N2;
            end
            gsspp = gsspp + gsspp_temp*c1*N1;   
    end    
gabcd = gsspp;

elseif( L1 == 0 && L2 == 1 && L3 == 1 && L4 == 0)

gspps = zeros(1,3,3,1);

%fun is a function handle. I could use VRR, HRR, etc


    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gspps_temp = zeros(1,3,3,1);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                %RPA = [Px-g1.x0;Py-g1.y0;Pz-g1.z0];
                %RPB = [Px-g2.x0;Py-g2.y0;Pz-g2.z0];
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;

                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gspps_temp2 = zeros(1,3,3,1);
                
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gspps_temp3 = zeros(1,3,3,1);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

%                             A_CD = EcdX*EcdY*EcdZ*basis_c.c(nc)*basis_d.c(nd)*basis_c.g(nc).N*basis_d.g(nd).N;
                            %RQC = [Qx-g3.x0;Qy-g3.y0;Qz-g3.z0];
                            %RQD = [Qx-g4.x0;Qy-g4.y0;Qz-g4.z0];
                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
%                             RCDx = g3.x0-g4.x0;
%                             RCDy = g3.y0-g4.y0;
%                             RCDz = g3.z0-g4.z0;
%                             Wx = (p*Px+q*Qx)/(p+q);
%                             Wy = (p*Py+q*Qy)/(p+q);
%                             Wz = (p*Pz+q*Qz)/(p+q);
                            %Wx - Px = (p*Px+q*Qx)/(p+q)-Px =
                            %(p-(p+q))*Px/(p+q)+q/(p+q)*Qx =
                            %-q/(p+q)*Px+q/(p+q)*Qx = -q/(p+q)(Px-Qx)
                            

                            
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                            
                            
                            
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                            
                            %gabcd(a,b,c,d) = gabcd(a,b,c,d)+A_AB*A_CD*Boys(0,alpha*RPQ2)*2*pi^2.5/(p*pp*sqrt(p+pp)); 
                            %temp3 = temp3 + vrr_1minimal(Kab,Kcd,RPA,RWP,p,q,alpha,RPQ2,L1,order,Boys_Table)*c4*N4;
                            %For checking the different recursion
                            %strategies
                            %temp3 = temp3 + vrr_1old(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,[0;0;0],[0;0;0],[0;0;0],RWP,[0;0;0],p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,L1,order,Boys_Table,nz)*c4*N4;
                            %temp3 = temp3 + vrr_1(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,Lmax,order,Boys_Table,nz)*c4*N4;
                            
                            gspps_temp4 = OSspps(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gspps_temp3 = gspps_temp3 + gspps_temp4*c4*N4;
                            
                        end
                        gspps_temp2 = gspps_temp2 + gspps_temp3*c3*N3;

                    end
                    gspps_temp = gspps_temp + gspps_temp2*c2*N2;

            end
            gspps = gspps + gspps_temp*c1*N1;

        
    end    
gabcd = gspps;

elseif( L1 == 0 && L2 == 1 && L3 == 0 && L4 == 1)

gspsp = zeros(1,3,1,3);

%fun is a function handle. I could use VRR, HRR, etc


    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gspsp_temp = zeros(1,3,1,3);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                %RPA = [Px-g1.x0;Py-g1.y0;Pz-g1.z0];
                %RPB = [Px-g2.x0;Py-g2.y0;Pz-g2.z0];
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;

                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gspsp_temp2 = zeros(1,3,1,3);
                
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gspsp_temp3 = zeros(1,3,1,3);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

%                             A_CD = EcdX*EcdY*EcdZ*basis_c.c(nc)*basis_d.c(nd)*basis_c.g(nc).N*basis_d.g(nd).N;
                            %RQC = [Qx-g3.x0;Qy-g3.y0;Qz-g3.z0];
                            %RQD = [Qx-g4.x0;Qy-g4.y0;Qz-g4.z0];
                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
%                             RCDx = g3.x0-g4.x0;
%                             RCDy = g3.y0-g4.y0;
%                             RCDz = g3.z0-g4.z0;
%                             Wx = (p*Px+q*Qx)/(p+q);
%                             Wy = (p*Py+q*Qy)/(p+q);
%                             Wz = (p*Pz+q*Qz)/(p+q);
                            %Wx - Px = (p*Px+q*Qx)/(p+q)-Px =
                            %(p-(p+q))*Px/(p+q)+q/(p+q)*Qx =
                            %-q/(p+q)*Px+q/(p+q)*Qx = -q/(p+q)(Px-Qx)
                            

                            
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                            
                            
                            
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                            
                            %gabcd(a,b,c,d) = gabcd(a,b,c,d)+A_AB*A_CD*Boys(0,alpha*RPQ2)*2*pi^2.5/(p*pp*sqrt(p+pp)); 
                            %temp3 = temp3 + vrr_1minimal(Kab,Kcd,RPA,RWP,p,q,alpha,RPQ2,L1,order,Boys_Table)*c4*N4;
                            %For checking the different recursion
                            %strategies
                            %temp3 = temp3 + vrr_1old(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,[0;0;0],[0;0;0],[0;0;0],RWP,[0;0;0],p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,L1,order,Boys_Table,nz)*c4*N4;
                            %temp3 = temp3 + vrr_1(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,Lmax,order,Boys_Table,nz)*c4*N4;
                            
                            gspsp_temp4 = OSspsp(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gspsp_temp3 = gspsp_temp3 + gspsp_temp4*c4*N4;
                            
                        end
                        gspsp_temp2 = gspsp_temp2 + gspsp_temp3*c3*N3;

                    end
                    gspsp_temp = gspsp_temp + gspsp_temp2*c2*N2;

            end
            gspsp = gspsp + gspsp_temp*c1*N1;

        
    end    
gabcd = gspsp;

elseif( L1 == 1 && L2 == 0 && L3 == 0 && L4 == 1)

gpssp = zeros(3,1,1,3);

%fun is a function handle. I could use VRR, HRR, etc


    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gpssp_temp = zeros(3,1,1,3);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                %RPA = [Px-g1.x0;Py-g1.y0;Pz-g1.z0];
                %RPB = [Px-g2.x0;Py-g2.y0;Pz-g2.z0];
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;

                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gpssp_temp2 = zeros(3,1,1,3);
                
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gpssp_temp3 = zeros(3,1,1,3);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

%                             A_CD = EcdX*EcdY*EcdZ*basis_c.c(nc)*basis_d.c(nd)*basis_c.g(nc).N*basis_d.g(nd).N;
                            %RQC = [Qx-g3.x0;Qy-g3.y0;Qz-g3.z0];
                            %RQD = [Qx-g4.x0;Qy-g4.y0;Qz-g4.z0];
                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
%                             RCDx = g3.x0-g4.x0;
%                             RCDy = g3.y0-g4.y0;
%                             RCDz = g3.z0-g4.z0;
%                             Wx = (p*Px+q*Qx)/(p+q);
%                             Wy = (p*Py+q*Qy)/(p+q);
%                             Wz = (p*Pz+q*Qz)/(p+q);
                            %Wx - Px = (p*Px+q*Qx)/(p+q)-Px =
                            %(p-(p+q))*Px/(p+q)+q/(p+q)*Qx =
                            %-q/(p+q)*Px+q/(p+q)*Qx = -q/(p+q)(Px-Qx)
                            

                            
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                            
                            
                            
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                            
                            %gabcd(a,b,c,d) = gabcd(a,b,c,d)+A_AB*A_CD*Boys(0,alpha*RPQ2)*2*pi^2.5/(p*pp*sqrt(p+pp)); 
                            %temp3 = temp3 + vrr_1minimal(Kab,Kcd,RPA,RWP,p,q,alpha,RPQ2,L1,order,Boys_Table)*c4*N4;
                            %For checking the different recursion
                            %strategies
                            %temp3 = temp3 + vrr_1old(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,[0;0;0],[0;0;0],[0;0;0],RWP,[0;0;0],p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,L1,order,Boys_Table,nz)*c4*N4;
                            %temp3 = temp3 + vrr_1(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,Lmax,order,Boys_Table,nz)*c4*N4;
                            
                            gpssp_temp4 = OSpssp(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gpssp_temp3 = gpssp_temp3 + gpssp_temp4*c4*N4;
                            
                        end
                        gpssp_temp2 = gpssp_temp2 + gpssp_temp3*c3*N3;

                    end
                    gpssp_temp = gpssp_temp + gpssp_temp2*c2*N2;

            end
            gpssp = gpssp + gpssp_temp*c1*N1;

        
    end    
gabcd = gpssp;

elseif( L1 == 1 && L2 == 0 && L3 == 1 && L4 == 0)

gpsps = zeros(3,1,3,1);

%fun is a function handle. I could use VRR, HRR, etc


    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gpsps_temp = zeros(3,1,3,1);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                %RPA = [Px-g1.x0;Py-g1.y0;Pz-g1.z0];
                %RPB = [Px-g2.x0;Py-g2.y0;Pz-g2.z0];
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;

                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gpsps_temp2 = zeros(3,1,3,1);
                
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gpsps_temp3 = zeros(3,1,3,1);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

%                             A_CD = EcdX*EcdY*EcdZ*basis_c.c(nc)*basis_d.c(nd)*basis_c.g(nc).N*basis_d.g(nd).N;
                            %RQC = [Qx-g3.x0;Qy-g3.y0;Qz-g3.z0];
                            %RQD = [Qx-g4.x0;Qy-g4.y0;Qz-g4.z0];
                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
%                             RCDx = g3.x0-g4.x0;
%                             RCDy = g3.y0-g4.y0;
%                             RCDz = g3.z0-g4.z0;
%                             Wx = (p*Px+q*Qx)/(p+q);
%                             Wy = (p*Py+q*Qy)/(p+q);
%                             Wz = (p*Pz+q*Qz)/(p+q);
                            %Wx - Px = (p*Px+q*Qx)/(p+q)-Px =
                            %(p-(p+q))*Px/(p+q)+q/(p+q)*Qx =
                            %-q/(p+q)*Px+q/(p+q)*Qx = -q/(p+q)(Px-Qx)
                            

                            
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                            
                            
                            
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                            
                            %gabcd(a,b,c,d) = gabcd(a,b,c,d)+A_AB*A_CD*Boys(0,alpha*RPQ2)*2*pi^2.5/(p*pp*sqrt(p+pp)); 
                            %temp3 = temp3 + vrr_1minimal(Kab,Kcd,RPA,RWP,p,q,alpha,RPQ2,L1,order,Boys_Table)*c4*N4;
                            %For checking the different recursion
                            %strategies
                            %temp3 = temp3 + vrr_1old(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,[0;0;0],[0;0;0],[0;0;0],RWP,[0;0;0],p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,L1,order,Boys_Table,nz)*c4*N4;
                            %temp3 = temp3 + vrr_1(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,Lmax,order,Boys_Table,nz)*c4*N4;
                            
                            gpsps_temp4 = OSpsps(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gpsps_temp3 = gpsps_temp3 + gpsps_temp4*c4*N4;
                            
                        end
                        gpsps_temp2 = gpsps_temp2 + gpsps_temp3*c3*N3;

                    end
                    gpsps_temp = gpsps_temp + gpsps_temp2*c2*N2;

            end
            gpsps = gpsps + gpsps_temp*c1*N1;

        
    end    
gabcd = gpsps;

elseif( L1 == 1 && L2 == 1 && L3 == 1 && L4 == 0)

gppps = zeros(3,3,3,1);

    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gppps_temp = zeros(3,3,3,1);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;
                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gppps_temp2 = zeros(3,3,3,1);
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gppps_temp3 = zeros(3,3,3,1);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
                        
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                       
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                                     
                            gppps_temp4 = OSppps(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gppps_temp3 = gppps_temp3 + gppps_temp4*c4*N4;
                            
                        end
                        gppps_temp2 = gppps_temp2 + gppps_temp3*c3*N3;
                    end
                    gppps_temp = gppps_temp + gppps_temp2*c2*N2;
            end
            gppps = gppps + gppps_temp*c1*N1;   
    end    
gabcd = gppps;

elseif( L1 == 1 && L2 == 1 && L3 == 0 && L4 == 1)

gppsp = zeros(3,3,1,3);

    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gppsp_temp = zeros(3,3,1,3);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;
                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gppsp_temp2 = zeros(3,3,1,3);
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gppsp_temp3 = zeros(3,3,1,3);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
                        
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                       
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                                     
                            gppsp_temp4 = OSppsp(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gppsp_temp3 = gppsp_temp3 + gppsp_temp4*c4*N4;
                            
                        end
                        gppsp_temp2 = gppsp_temp2 + gppsp_temp3*c3*N3;
                    end
                    gppsp_temp = gppsp_temp + gppsp_temp2*c2*N2;
            end
            gppsp = gppsp + gppsp_temp*c1*N1;   
    end    
gabcd = gppsp;

elseif( L1 == 1 && L2 == 1 && L3 == 1 && L4 == 1)

gpppp = zeros(3,3,3,3);

%fun is a function handle. I could use VRR, HRR, etc


    for na=1:basis_a.n %loops over the number of primitives in the 1st contracted basis function
        g1 = basis_a.g(na);
        aa = g1.alpha;
        c1 = basis_a.c(na);
        N1 = g1.N;
        gpppp_temp = zeros(3,3,3,3);
               
            for nb=1:basis_b.n %loops over number of primitives in the 2nd contracted basis function
                g2 = basis_b.g(nb);
                ab = g2.alpha;
                c2 = basis_b.c(nb);
                N2 = g2.N;
                
                p = aa + ab;
                Px = (aa*g1.x0 + ab*g2.x0)/p;
                Py = (aa*g1.y0 + ab*g2.y0)/p;
                Pz = (aa*g1.z0 + ab*g2.z0)/p;
                
                %RPA = [Px-g1.x0;Py-g1.y0;Pz-g1.z0];
                %RPB = [Px-g2.x0;Py-g2.y0;Pz-g2.z0];
                RAB = [g1.x0-g2.x0;g1.y0-g2.y0;g1.z0-g2.z0]; %column vector
                RPA = -ab/p*RAB;
                RPB = aa/p*RAB;

                
                rhoAB = aa*ab/p;
                Kab = exp(-rhoAB*(RAB(1)^2+RAB(2)^2+RAB(3)^2));
                
                gpppp_temp2 = zeros(3,3,3,3);
                
                
                    for nc = 1:basis_c.n; %loop over number of primitives in 3rd contracted basis function 
                        g3 = basis_c.g(nc);
                        ac = g3.alpha;
                        c3 = basis_c.c(nc);
                        N3 = g3.N;
                        
                        gpppp_temp3 = zeros(3,3,3,3);

                        for nd = 1:basis_d.n; %loops over number of primitives in 4th contracted basis functions.
                            
                            g4 = basis_d.g(nd);
                            ad = g4.alpha;
                            c4 = basis_d.c(nd);
                            N4 = g4.N;
                            
                            q = ac+ad;
                            Qx = (ac*g3.x0 + ad*g4.x0)/q;
                            Qy = (ac*g3.y0 + ad*g4.y0)/q;
                            Qz = (ac*g3.z0 + ad*g4.z0)/q;

%                             A_CD = EcdX*EcdY*EcdZ*basis_c.c(nc)*basis_d.c(nd)*basis_c.g(nc).N*basis_d.g(nd).N;
                            %RQC = [Qx-g3.x0;Qy-g3.y0;Qz-g3.z0];
                            %RQD = [Qx-g4.x0;Qy-g4.y0;Qz-g4.z0];
                            RCD = [g3.x0-g4.x0;g3.y0-g4.y0;g3.z0-g4.z0];
                            RQC = -ad/q*RCD;
                            RQD = ac/q*RCD;
%                             RCDx = g3.x0-g4.x0;
%                             RCDy = g3.y0-g4.y0;
%                             RCDz = g3.z0-g4.z0;
%                             Wx = (p*Px+q*Qx)/(p+q);
%                             Wy = (p*Py+q*Qy)/(p+q);
%                             Wz = (p*Pz+q*Qz)/(p+q);
                            %Wx - Px = (p*Px+q*Qx)/(p+q)-Px =
                            %(p-(p+q))*Px/(p+q)+q/(p+q)*Qx =
                            %-q/(p+q)*Px+q/(p+q)*Qx = -q/(p+q)(Px-Qx)
                            

                            
                            rhoCD = ac*ad/q;
                            Kcd = exp(-rhoCD*(RCD(1)^2+RCD(2)^2+RCD(3)^2));
                            
                            
                            
                            RPQ = [Px-Qx;Py-Qy;Pz-Qz]; %column vector
                            RWP = -q/(p+q)*RPQ;
                            RWQ = p/(p+q)*RPQ;
                            RPQ2 = RPQ(1)^2+RPQ(2)^2+RPQ(3)^2;
                            alpha = q*p/(q+p);
                            
                            %gabcd(a,b,c,d) = gabcd(a,b,c,d)+A_AB*A_CD*Boys(0,alpha*RPQ2)*2*pi^2.5/(p*pp*sqrt(p+pp)); 
                            %temp3 = temp3 + vrr_1minimal(Kab,Kcd,RPA,RWP,p,q,alpha,RPQ2,L1,order,Boys_Table)*c4*N4;
                            %For checking the different recursion
                            %strategies
                            %temp3 = temp3 + vrr_1old(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,[0;0;0],[0;0;0],[0;0;0],RWP,[0;0;0],p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,L1,order,Boys_Table,nz)*c4*N4;
                            %temp3 = temp3 + vrr_1(aa,ab,ac,ad,Kab,Kcd,RAB,RCD,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,RPQ,alpha,RPQ2,L1,L2,L3,L4,Lmax,order,Boys_Table,nz)*c4*N4;
                            
                            gpppp_temp4 = OSpppp(Kab,Kcd,RPA,RPB,RQC,RQD,RWP,RWQ,p,q,alpha,RPQ2,Boys_Table);
                            gpppp_temp3 = gpppp_temp3 + gpppp_temp4*c4*N4;
                            
                        end
                        gpppp_temp2 = gpppp_temp2 + gpppp_temp3*c3*N3;

                    end
                    gpppp_temp = gpppp_temp + gpppp_temp2*c2*N2;

            end
            gpppp = gpppp + gpppp_temp*c1*N1;

        
    end

gabcd = gpppp;


end  %if  
    
end